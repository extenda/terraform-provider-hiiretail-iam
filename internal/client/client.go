package client

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
)

// IClient is an interface for the HiiRetail IAM API client.
// It provides methods for managing IAM groups, including CRUD operations
// with proper error handling, retry logic, and timeout management.
type IClient interface {
	CreateGroup(ctx context.Context, name string, description string) (*Group, error)
	GetGroup(ctx context.Context, id string) (*Group, error)
	UpdateGroup(ctx context.Context, id string, name string, description string) (*Group, error)
	DeleteGroup(ctx context.Context, id string) error
}

// Client represents the HiiRetail IAM API client
type Client struct {
	baseURL    string
	httpClient *http.Client
	token      string
	retry      RetryConfig
	logger     *Logger
	timeouts   TimeoutConfig
}

// NewClient creates a new HiiRetail IAM API client with default configurations for:
// - HTTP client settings
// - Retry behavior
// - Logging (INFO level)
// - Operation timeouts
//
// Parameters:
//   - baseURL: The base URL of the HiiRetail IAM API (e.g., "https://api.hiiretail.com/v1")
//   - token: The authentication token for API requests
//
// The client automatically handles:
//   - Authentication via Bearer token
//   - Request retries with exponential backoff
//   - Logging of requests and responses
//   - Proper timeout management
//   - Error wrapping and status code handling
func NewClient(baseURL string, token string) *Client {
	return &Client{
		baseURL:    strings.TrimSuffix(baseURL, "/"),
		httpClient: &http.Client{},
		token:      token,
		retry:      DefaultRetryConfig,
		logger:     NewLogger(LogLevelInfo),
		timeouts:   DefaultTimeoutConfig,
	}
}

// Group represents an IAM group in the HiiRetail system.
// It contains the core attributes that identify and describe a group.
//
// Fields:
//   - ID: Unique identifier for the group (generated by the API)
//   - Name: Human-readable name for the group (must be unique)
//   - Description: Optional description explaining the group's purpose
type Group struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

// CreateGroup creates a new IAM group
func (c *Client) CreateGroup(ctx context.Context, name string, description string) (*Group, error) {
	var result *Group
	err := withTimeout(ctx, c.timeouts.Create, func(ctx context.Context) error {
		payload := map[string]interface{}{
			"name":        name,
			"description": description,
		}

		data, err := json.Marshal(payload)
		if err != nil {
			return fmt.Errorf("failed to marshal group payload: %w", err)
		}

		req, err := c.newRequest(ctx, http.MethodPost, "/groups", strings.NewReader(string(data)))
		if err != nil {
			return err
		}

		var group Group
		if err := c.do(req, &group); err != nil {
			return err
		}

		result = &group
		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

// GetGroup retrieves an IAM group by ID
func (c *Client) GetGroup(ctx context.Context, id string) (*Group, error) {
	var result *Group
	err := withTimeout(ctx, c.timeouts.Read, func(ctx context.Context) error {
		req, err := c.newRequest(ctx, http.MethodGet, fmt.Sprintf("/groups/%s", id), nil)
		if err != nil {
			return err
		}

		var group Group
		if err := c.do(req, &group); err != nil {
			return err
		}

		result = &group
		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

// UpdateGroup updates an existing IAM group
func (c *Client) UpdateGroup(ctx context.Context, id string, name string, description string) (*Group, error) {
	var result *Group
	err := withTimeout(ctx, c.timeouts.Update, func(ctx context.Context) error {
		payload := map[string]interface{}{
			"name":        name,
			"description": description,
		}

		data, err := json.Marshal(payload)
		if err != nil {
			return fmt.Errorf("failed to marshal group payload: %w", err)
		}

		req, err := c.newRequest(ctx, http.MethodPut, fmt.Sprintf("/groups/%s", id), strings.NewReader(string(data)))
		if err != nil {
			return err
		}

		var group Group
		if err := c.do(req, &group); err != nil {
			return err
		}

		result = &group
		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

// DeleteGroup deletes an IAM group
func (c *Client) DeleteGroup(ctx context.Context, id string) error {
	return withTimeout(ctx, c.timeouts.Delete, func(ctx context.Context) error {
		req, err := c.newRequest(ctx, http.MethodDelete, fmt.Sprintf("/groups/%s", id), nil)
		if err != nil {
			return err
		}

		return c.do(req, nil)
	})
}

// newRequest creates a new HTTP request with common headers
func (c *Client) newRequest(ctx context.Context, method string, path string, body io.Reader) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+c.token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	return req, nil
}

// do performs an HTTP request and decodes the response
func (c *Client) do(req *http.Request, v interface{}) error {
	var attemptCount = 0
	
	resp, err := withRetry(req.Context(), c.retry, func() (*http.Response, error) {
		attemptCount++
		// Create a new request for each retry since the body might need to be re-read
		newReq, err := c.newRequest(req.Context(), req.Method, strings.TrimPrefix(req.URL.Path, c.baseURL), nil)
		if err != nil {
			c.logger.Error("Failed to create request: %v", err)
			return nil, err
		}
		newReq.Header = req.Header
		
		if req.Body != nil {
			// Read the original body
			body, err := io.ReadAll(req.Body)
			if err != nil {
				c.logger.Error("Failed to read request body: %v", err)
				return nil, err
			}
			newReq.Body = io.NopCloser(strings.NewReader(string(body)))
		}
		
		c.logger.LogRequest(newReq)
		resp, err := c.httpClient.Do(newReq)
		if err != nil {
			c.logger.Error("Request failed: %v", err)
			c.logger.LogRetry(attemptCount, err)
			return nil, err
		}
		c.logger.LogResponse(resp)
		
		return resp, nil
	})

	if err != nil {
		return fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 && !isRetryable(resp, nil) {
		body, _ := io.ReadAll(resp.Body)
		c.logger.Error("Request failed with status %d: %s", resp.StatusCode, string(body))
		
		if resp.StatusCode == http.StatusNotFound {
			// Extract resource type from URL path
			pathParts := strings.Split(strings.Trim(req.URL.Path, "/"), "/")
			resourceType := ""
			id := ""
			if len(pathParts) >= 2 {
				resourceType = pathParts[0]
				id = pathParts[1]
			}
			return &ResourceNotFoundError{
				ResourceType: resourceType,
				ID:          id,
			}
		}
		
		return fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	if v != nil {
		if err := json.NewDecoder(resp.Body).Decode(v); err != nil {
			c.logger.Error("Failed to decode response: %v", err)
			return fmt.Errorf("failed to decode response: %w", err)
		}
		c.logger.Debug("Successfully decoded response")
	}

	return nil
}